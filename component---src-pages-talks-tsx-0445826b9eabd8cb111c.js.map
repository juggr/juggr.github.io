{"version":3,"file":"component---src-pages-talks-tsx-0445826b9eabd8cb111c.js","mappings":"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","sources":["webpack://jug-goerlitz/./src/pages/talks.tsx","webpack://jug-goerlitz/./src/utils/find-speakers-for-talk.ts","webpack://jug-goerlitz/./src/utils/format-date.ts","webpack://jug-goerlitz/./src/utils/get-upcoming-event.ts","webpack://jug-goerlitz/./node_modules/moment/locale/de.js"],"sourcesContent":["import React from \"react\"\n\nimport { graphql, Link } from \"gatsby\"\n\nimport Layout from \"../components/layout\"\n\nimport formatDate from \"../utils/format-date\"\n\nimport * as R from \"ramda\"\n\nimport { getUpcomingEvent } from \"../utils/get-upcoming-event\"\nimport { findSpeakersForTalk } from \"../utils/find-speakers-for-talk\"\n\nconst TalksPage = ({ data }) => {\n  const talks = data.talks.edges.map((edge) => edge.node)\n\n  const allSpeakers = data.speakers.edges.map((edge) => edge.node)\n\n  const today = new Date()\n\n  const upcomingEvent = getUpcomingEvent({ allEvents: talks, today })\n\n  return (\n    <Layout>\n      <h2>Alle Vortragsthemen</h2>\n\n      <ul>\n        {talks.map((talk) => {\n          const speakersOfTalk = findSpeakersForTalk({ allSpeakers, talk })\n\n          const speakersString = R.join(\", \")(speakersOfTalk.map((speaker) => speaker.frontmatter.name))\n\n          const isNextTalk = upcomingEvent && talk.frontmatter.date === upcomingEvent.frontmatter.date\n\n          const style = isNextTalk ? { backgroundColor: \"rgb(231, 231, 231)\" } : undefined\n\n          return (\n            <li key={talk.id} style={style}>\n              <span className=\"lead\">\n                <Link to={talk.fields.slug}>{talk.frontmatter.title}</Link>\n              </span>\n              {\" | \"}\n              <time dateTime={talk.frontmatter.date}>{formatDate(talk.frontmatter.date)}</time>\n              <p>von {speakersString}</p>\n            </li>\n          )\n        })}\n      </ul>\n    </Layout>\n  )\n}\n\nexport default TalksPage\n\nexport const query = graphql`\n  {\n    talks: allMarkdownRemark(\n      sort: { frontmatter: { date: DESC } }\n      filter: { fields: { sourceName: { eq: \"talks\" } } }\n    ) {\n      edges {\n        node {\n          id\n          frontmatter {\n            title\n            date\n            time\n            virtual\n            tags\n            speaker\n          }\n          fields {\n            slug\n          }\n        }\n      }\n    }\n    speakers: allMarkdownRemark(filter: { fields: { sourceName: { eq: \"speakers\" } } }) {\n      edges {\n        node {\n          id\n          fields {\n            slug\n          }\n          frontmatter {\n            name\n          }\n        }\n      }\n    }\n  }\n`\n\nexport { Head } from \"../components/head\"\n","import * as R from \"ramda\"\n\n/**\n * For each talk we cannot directly query the speaker info (especially the name) but only the speakerSlugs (not the full slug but the important\n * speaker-identifier with which we can create the slug)\n * we have to query all speakers in a separate query. Then we need to extract from this allSpeakers-list\n * only those speaker info objects that belong to a given talk. This is what this method is doing.\n *\n * @param allSpeakers an array of all speaker objects\n * @param talk a talk object\n */\nexport const findSpeakersForTalk = ({ allSpeakers, talk }) => {\n  return R.innerJoin(\n    (speaker, slug) => speaker.fields.slug === `/speakers/${slug}/`,\n    allSpeakers,\n    talk.frontmatter.speaker\n  )\n}\n","import moment from \"moment\"\n\nimport \"moment/locale/de\"\n\nmoment.locale(\"de\")\n\nconst formatDate = (date) => moment(date).format(\"LL\")\n\nexport default formatDate\n","import moment from \"moment/moment\"\nimport * as R from \"ramda\"\n\n// TODO: fix typing\n\n/**\n * This function is used to determine the next upcoming event based on a list of events and the current date.\n * This is used to mark the next event in the list of all events and to determine which talk to show on the front page.\n *\n * If there is no event in the list the is in the future of today, then the last event is used.\n *\n *\n * @param allEvents a list of events\n * @param extractDate an optional function to extract the date from the event objects.\n * If no function is provided then a property \"frontmatter.date\" is used based on the markdown standard\n * @param today a date object of today. Usualy created by \"new Date()\" or a string representing today.\n * Basically anything that can parsed by moment.js\n */\nexport const getUpcomingEvent = ({\n  allEvents,\n  extractDate,\n  today,\n}: {\n  allEvents: Array<any>\n  extractDate?: any\n  today?: Date | string\n}) => {\n  if (!allEvents) {\n    return undefined\n  }\n\n  const extractor = extractDate ? extractDate : (edge) => edge.frontmatter.date\n\n  const sortedEvents = R.sortBy(extractor)(allEvents)\n\n  if (sortedEvents.length === 1) {\n    return sortedEvents[0]\n  }\n\n  const todayMoment = moment(today).startOf(\"day\")\n\n  const datesAfter = R.filter((event) => {\n    const date = moment(extractor(event)).startOf(\"day\")\n\n    return todayMoment.isSameOrBefore(date)\n  })(sortedEvents)\n\n  if (datesAfter && datesAfter.length > 0) {\n    return datesAfter[0]\n  } else {\n    return R.reverse(sortedEvents)[0]\n  }\n}\n","//! moment.js locale configuration\n//! locale : German [de]\n//! author : lluchs : https://github.com/lluchs\n//! author: Menelion Elensúle: https://github.com/Oire\n//! author : Mikolaj Dadela : https://github.com/mik01aj\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../moment')) :\n   typeof define === 'function' && define.amd ? define(['../moment'], factory) :\n   factory(global.moment)\n}(this, (function (moment) { 'use strict';\n\n    //! moment.js locale configuration\n\n    function processRelativeTime(number, withoutSuffix, key, isFuture) {\n        var format = {\n            m: ['eine Minute', 'einer Minute'],\n            h: ['eine Stunde', 'einer Stunde'],\n            d: ['ein Tag', 'einem Tag'],\n            dd: [number + ' Tage', number + ' Tagen'],\n            w: ['eine Woche', 'einer Woche'],\n            M: ['ein Monat', 'einem Monat'],\n            MM: [number + ' Monate', number + ' Monaten'],\n            y: ['ein Jahr', 'einem Jahr'],\n            yy: [number + ' Jahre', number + ' Jahren'],\n        };\n        return withoutSuffix ? format[key][0] : format[key][1];\n    }\n\n    var de = moment.defineLocale('de', {\n        months: 'Januar_Februar_März_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split(\n            '_'\n        ),\n        monthsShort:\n            'Jan._Feb._März_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.'.split('_'),\n        monthsParseExact: true,\n        weekdays:\n            'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split(\n                '_'\n            ),\n        weekdaysShort: 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),\n        weekdaysMin: 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),\n        weekdaysParseExact: true,\n        longDateFormat: {\n            LT: 'HH:mm',\n            LTS: 'HH:mm:ss',\n            L: 'DD.MM.YYYY',\n            LL: 'D. MMMM YYYY',\n            LLL: 'D. MMMM YYYY HH:mm',\n            LLLL: 'dddd, D. MMMM YYYY HH:mm',\n        },\n        calendar: {\n            sameDay: '[heute um] LT [Uhr]',\n            sameElse: 'L',\n            nextDay: '[morgen um] LT [Uhr]',\n            nextWeek: 'dddd [um] LT [Uhr]',\n            lastDay: '[gestern um] LT [Uhr]',\n            lastWeek: '[letzten] dddd [um] LT [Uhr]',\n        },\n        relativeTime: {\n            future: 'in %s',\n            past: 'vor %s',\n            s: 'ein paar Sekunden',\n            ss: '%d Sekunden',\n            m: processRelativeTime,\n            mm: '%d Minuten',\n            h: processRelativeTime,\n            hh: '%d Stunden',\n            d: processRelativeTime,\n            dd: processRelativeTime,\n            w: processRelativeTime,\n            ww: '%d Wochen',\n            M: processRelativeTime,\n            MM: processRelativeTime,\n            y: processRelativeTime,\n            yy: processRelativeTime,\n        },\n        dayOfMonthOrdinalParse: /\\d{1,2}\\./,\n        ordinal: '%d.',\n        week: {\n            dow: 1, // Monday is the first day of the week.\n            doy: 4, // The week that contains Jan 4th is the first week of the year.\n        },\n    });\n\n    return de;\n\n})));\n"],"names":["_ref","data","talks","edges","map","edge","node","allSpeakers","speakers","today","Date","upcomingEvent","getUpcomingEvent","allEvents","React","Layout","talk","speakersOfTalk","findSpeakersForTalk","speakersString","R","speaker","frontmatter","name","style","date","backgroundColor","undefined","key","id","className","Link","to","fields","slug","title","dateTime","formatDate","moment","format","extractDate","extractor","sortedEvents","length","todayMoment","startOf","datesAfter","event","isSameOrBefore","processRelativeTime","number","withoutSuffix","isFuture","m","h","d","dd","w","M","MM","y","yy","defineLocale","months","split","monthsShort","monthsParseExact","weekdays","weekdaysShort","weekdaysMin","weekdaysParseExact","longDateFormat","LT","LTS","L","LL","LLL","LLLL","calendar","sameDay","sameElse","nextDay","nextWeek","lastDay","lastWeek","relativeTime","future","past","s","ss","mm","hh","ww","dayOfMonthOrdinalParse","ordinal","week","dow","doy","factory"],"sourceRoot":""}