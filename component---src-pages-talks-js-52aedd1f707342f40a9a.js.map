{"version":3,"sources":["webpack:///./src/pages/talks.js","webpack:///./src/utils/get-upcoming-event.js"],"names":["TalksPage","data","talks","edges","map","edge","node","allSpeakers","speakers","today","Date","upcomingEvent","getUpcomingEvent","allEvents","talk","speakersOfTalk","findSpeakersForTalk","speakersString","R","speaker","frontmatter","name","style","date","backgroundColor","undefined","key","id","className","to","fields","slug","title","dateTime","formatDate","extractDate","extractor","sortedEvents","length","todayMoment","moment","startOf","datesAfter","event","isSameOrBefore"],"mappings":"8FAAA,iHAoDeA,UAvCG,SAAC,GAAc,IAAZC,EAAW,EAAXA,KACbC,EAAQD,EAAKC,MAAMC,MAAMC,KAAI,SAAAC,GAAI,OAAIA,EAAKC,QAE1CC,EAAcN,EAAKO,SAASL,MAAMC,KAAI,SAAAC,GAAI,OAAIA,EAAKC,QAEnDG,EAAQ,IAAIC,KAEZC,EAAgBC,YAAiB,CAAEC,UAAWX,EAAOO,UAE3D,OACE,kBAAC,IAAD,KACE,mDAEA,4BACGP,EAAME,KAAI,SAAAU,GACT,IAAMC,EAAiBC,IAAoB,CAAET,cAAaO,SAEpDG,EAAiBC,IAAO,KAAPA,CAAaH,EAAeX,KAAI,SAAAe,GAAO,OAAIA,EAAQC,YAAYC,SAIhFC,EAFaX,GAAiBG,EAAKM,YAAYG,OAASZ,EAAcS,YAAYG,KAE7D,CAAEC,gBAAiB,2BAAyBC,EAEvE,OACE,wBAAIC,IAAKZ,EAAKa,GAAIL,MAAOA,GACvB,0BAAMM,UAAU,QACd,kBAAC,OAAD,CAAMC,GAAIf,EAAKgB,OAAOC,MAAOjB,EAAKM,YAAYY,QAE/C,MACD,0BAAMC,SAAUnB,EAAKM,YAAYG,MAAOW,YAAWpB,EAAKM,YAAYG,OACpE,kCAAQN,W,oCC3CtB,6DA4CeL,IA5BU,SAAC,GAAuC,IAArCC,EAAoC,EAApCA,UAAWsB,EAAyB,EAAzBA,YAAa1B,EAAY,EAAZA,MAClD,GAAII,EAAJ,CAIA,IAAMuB,EAAYD,GAA4B,SAAA9B,GAAI,OAAIA,EAAKe,YAAYG,MAEjEc,EAAenB,IAASkB,EAATlB,CAAoBL,GAEzC,GAA2B,IAAxBwB,EAAaC,OACd,OAAOD,EAAa,GAGtB,IAAME,EAAcC,IAAO/B,GAAOgC,QAAQ,OAEpCC,EAAaxB,KAAS,SAAAyB,GAC1B,IAAMpB,EAAOiB,IAAOJ,EAAUO,IAAQF,QAAQ,OAE9C,OAAOF,EAAYK,eAAerB,KAHjBL,CAIhBmB,GAEH,OAAGK,GAAcA,EAAWJ,OAAS,EAC5BI,EAAW,GAEXxB,IAAUmB,GAAc","file":"component---src-pages-talks-js-52aedd1f707342f40a9a.js","sourcesContent":["import React from \"react\"\r\n\r\nimport { graphql, Link } from \"gatsby\"\r\n\r\nimport Layout from \"../components/layout\"\r\n\r\nimport formatDate from \"../utils/format-date\"\r\n\r\nimport * as R from \"ramda\"\r\n\r\nimport getUpcomingEvent from \"../utils/get-upcoming-event\"\r\nimport findSpeakersForTalk from \"../utils/find-speakers-for-talk\"\r\n\r\nconst TalksPage = ({ data }) => {\r\n  const talks = data.talks.edges.map(edge => edge.node)\r\n\r\n  const allSpeakers = data.speakers.edges.map(edge => edge.node)\r\n\r\n  const today = new Date()\r\n\r\n  const upcomingEvent = getUpcomingEvent({ allEvents: talks, today })\r\n\r\n  return (\r\n    <Layout>\r\n      <h2>Alle Vortragsthemen</h2>\r\n\r\n      <ul>\r\n        {talks.map(talk => {\r\n          const speakersOfTalk = findSpeakersForTalk({ allSpeakers, talk })\r\n\r\n          const speakersString = R.join(\", \")(speakersOfTalk.map(speaker => speaker.frontmatter.name))\r\n\r\n          const isNextTalk = upcomingEvent && talk.frontmatter.date === upcomingEvent.frontmatter.date\r\n\r\n          const style = isNextTalk ? { backgroundColor: \"rgb(231, 231, 231)\" } : undefined\r\n\r\n          return (\r\n            <li key={talk.id} style={style}>\r\n              <span className=\"lead\">\r\n                <Link to={talk.fields.slug}>{talk.frontmatter.title}</Link>\r\n              </span>\r\n              {\" | \"}\r\n              <time dateTime={talk.frontmatter.date}>{formatDate(talk.frontmatter.date)}</time>\r\n              <p>von {speakersString}</p>\r\n            </li>\r\n          )\r\n        })}\r\n      </ul>\r\n    </Layout>\r\n  )\r\n}\r\n\r\nexport default TalksPage\r\n\r\nexport const query = graphql`\r\n  query {\r\n    talks: allMarkdownRemark(\r\n      sort: { fields: [frontmatter___date], order: DESC }\r\n      filter: { fields: { sourceName: { eq: \"talks\" } } }\r\n    ) {\r\n      edges {\r\n        node {\r\n          id\r\n          frontmatter {\r\n            title\r\n            date\r\n            time\r\n            virtual\r\n            tags\r\n            speaker\r\n          }\r\n          fields {\r\n            slug\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    speakers: allMarkdownRemark(filter: { fields: { sourceName: { eq: \"speakers\" } } }) {\r\n      edges {\r\n        node {\r\n          id\r\n          fields {\r\n            slug\r\n          }\r\n          frontmatter {\r\n            name\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n`\r\n","import moment from \"moment/moment\"\r\nimport * as R from \"ramda\"\r\n\r\n/**\r\n * This function is used to determine the next upcoming event based on a list of events and the current date.\r\n * This is used to mark the next event in the list of all events and to determine which talk to show on the front page.\r\n *\r\n * If there is no event in the list the is in the future of today, then the last event is used.\r\n *\r\n *\r\n * @param allEvents a list of events\r\n * @param extractDate an optional function to extract the date from the event objects.\r\n * If no function is provided then a property \"frontmatter.date\" is used based on the markdown standard\r\n * @param today a date object of today. Usualy created by \"new Date()\" or a string representing today.\r\n * Basically anything that can parsed by moment.js\r\n */\r\nconst getUpcomingEvent = ({ allEvents, extractDate, today }) => {\r\n  if(!allEvents) {\r\n    return undefined\r\n  }\r\n\r\n  const extractor = extractDate ? extractDate : edge => edge.frontmatter.date\r\n\r\n  const sortedEvents = R.sortBy(extractor)(allEvents)\r\n\r\n  if(sortedEvents.length === 1) {\r\n    return sortedEvents[0]\r\n  }\r\n\r\n  const todayMoment = moment(today).startOf(\"day\")\r\n\r\n  const datesAfter = R.filter(event => {\r\n    const date = moment(extractor(event)).startOf(\"day\")\r\n\r\n    return todayMoment.isSameOrBefore(date)\r\n  })(sortedEvents)\r\n\r\n  if(datesAfter && datesAfter.length > 0) {\r\n    return datesAfter[0]\r\n  } else {\r\n    return R.reverse(sortedEvents)[0]\r\n  }\r\n}\r\n\r\nexport default getUpcomingEvent"],"sourceRoot":""}