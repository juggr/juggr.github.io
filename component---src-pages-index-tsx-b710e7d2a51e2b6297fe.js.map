{"version":3,"file":"component---src-pages-index-tsx-b710e7d2a51e2b6297fe.js","mappings":"2PAYA,MAAMA,EAAWC,IAAA,IAAC,KAAEC,GAAM,SACxBC,EAAAA,cAAAA,MAAAA,KACEA,EAAAA,cAAAA,KAAAA,KACEA,EAAAA,cAACC,EAAAA,KAAI,CAACC,GAAIH,EAAKI,OAAOC,MAAOL,EAAKM,YAAYC,QAG/CP,EAAKM,YAAYE,MAAQP,EAAAA,cAAAA,IAAAA,MAAIQ,EAAAA,EAAAA,GAAWT,EAAKM,YAAYE,OAE1DP,EAAAA,cAAAA,MAAAA,CAAKS,wBAAyB,CAAEC,OAAQX,EAAKY,QAC7CX,EAAAA,cAAAA,KAAAA,MACI,EAwCR,UArCkBY,IAAc,IAAb,KAAEC,GAAM,EACzB,MAAMC,EAAQD,EAAKC,MAAMC,MAAMC,KAAKC,GAASA,EAAKC,OAC5CC,EAAQN,EAAKM,MAAQN,EAAKM,MAAMJ,MAAMC,KAAKC,GAASA,EAAKC,OAAQ,GAEvE,GAAIC,EAAMC,OAAS,EAAG,CACpB,MAAMC,EAAcC,EAAAA,IAAW,CAACA,EAAAA,KAAWvB,GAASA,EAAKM,YAAYE,QAAjDe,CAAyDH,GAE7E,OACEnB,EAAAA,cAACuB,EAAAA,EAAM,KACJF,EAAYL,KAAKjB,GAChBC,EAAAA,cAACH,EAAQ,CAAC2B,IAAKzB,EAAKI,OAAOC,KAAML,KAAMA,MAI/C,CAAO,CACL,MAAM0B,EAAQ,IAAIC,KAEZC,GAAgBC,EAAAA,EAAAA,GAAiB,CAAEC,UAAWf,EAAOW,WAErD,SAAEK,EAAQ,UAAEC,GAAclB,EAE1BmB,EAAcF,EAASf,MAAMC,KAAKC,GAASA,EAAKC,OAChDe,EAAeF,EAAUhB,MAAMC,KAAKC,GAASA,EAAKC,OAElDgB,EAAWZ,EAAAA,KAAUY,GAAaA,EAAS/B,OAAOgC,aAAeR,EAActB,YAAY6B,UAAhFZ,CACfW,GACA,GACIG,GAAiBC,EAAAA,EAAAA,GAAoB,CAAEL,cAAaM,KAAMX,IAEhE,OACE3B,EAAAA,cAACuB,EAAAA,EAAM,KACLvB,EAAAA,cAACuC,EAAAA,EAAW,CAACD,KAAMX,EAAea,YAAaJ,EAAgBF,SAAUA,EAAUO,mBAAmB,IAG5G,E,qEChDK,MAAMJ,EAAsBvC,IAA4B,IAA3B,YAAEkC,EAAW,KAAEM,GAAM,EACvD,OAAOhB,EAAAA,KACL,CAACoB,EAAStC,IAASsC,EAAQvC,OAAOC,OAAI,aAAkBA,EAAI,KAC5D4B,EACAM,EAAKjC,YAAYqC,QAClB,C,uFCEI,MAAMd,EAAmB9B,IAQzB,IAR0B,UAC/B+B,EAAS,YACTc,EAAW,MACXlB,GAKD,EACC,IAAKI,EACH,OAGF,MAAMe,EAAYD,GAA6B1B,IAASA,EAAKZ,YAAYE,MAEnEsC,EAAevB,EAAAA,IAASsB,EAATtB,CAAoBO,GAEzC,GAA4B,IAAxBgB,EAAazB,OACf,OAAOyB,EAAa,GAGtB,MAAMC,EAAcC,IAAOtB,GAAOuB,QAAQ,OAEpCC,EAAa3B,EAAAA,KAAU4B,IAC3B,MAAM3C,EAAOwC,IAAOH,EAAUM,IAAQF,QAAQ,OAE9C,OAAOF,EAAYK,eAAe5C,EAAK,GAHtBe,CAIhBuB,GAEH,OAAII,GAAcA,EAAW7B,OAAS,EAC7B6B,EAAW,GAEX3B,EAAAA,IAAUuB,GAAc,EACjC,C","sources":["webpack://jug-goerlitz/./src/pages/index.tsx","webpack://jug-goerlitz/./src/utils/find-speakers-for-talk.ts","webpack://jug-goerlitz/./src/utils/get-upcoming-event.ts"],"sourcesContent":["import React from \"react\"\n\nimport * as R from \"ramda\"\n\nimport { graphql, Link } from \"gatsby\"\n\nimport Layout from \"../components/layout\"\nimport { getUpcomingEvent } from \"../utils/get-upcoming-event\"\nimport formatDate from \"../utils/format-date\"\nimport TalkContent from \"../components/talk-content\"\nimport { findSpeakersForTalk } from \"../utils/find-speakers-for-talk\"\n\nconst PostPage = ({ post }) => (\n  <div>\n    <h2>\n      <Link to={post.fields.slug}>{post.frontmatter.title}</Link>\n    </h2>\n\n    {post.frontmatter.date && <p>{formatDate(post.frontmatter.date)}</p>}\n\n    <div dangerouslySetInnerHTML={{ __html: post.html }} />\n    <hr />\n  </div>\n)\n\nconst IndexPage = ({ data }) => {\n  const talks = data.talks.edges.map((edge) => edge.node)\n  const posts = data.posts ? data.posts.edges.map((edge) => edge.node) : []\n\n  if (posts.length > 0) {\n    const sortedPosts = R.sortWith([R.descend((post) => post.frontmatter.date)])(posts)\n\n    return (\n      <Layout>\n        {sortedPosts.map((post) => (\n          <PostPage key={post.fields.slug} post={post} />\n        ))}\n      </Layout>\n    )\n  } else {\n    const today = new Date()\n\n    const upcomingEvent = getUpcomingEvent({ allEvents: talks, today })\n\n    const { speakers, locations } = data\n\n    const allSpeakers = speakers.edges.map((edge) => edge.node)\n    const allLocations = locations.edges.map((edge) => edge.node)\n\n    const location = R.filter((location) => location.fields.locationId === upcomingEvent.frontmatter.location)(\n      allLocations\n    )[0]\n    const speakersOfTalk = findSpeakersForTalk({ allSpeakers, talk: upcomingEvent })\n\n    return (\n      <Layout>\n        <TalkContent talk={upcomingEvent} speakerList={speakersOfTalk} location={location} linkToDetailsPage={true} />\n      </Layout>\n    )\n  }\n}\n\nexport default IndexPage\n\nexport const query = graphql`\n  {\n    talks: allMarkdownRemark(filter: { fields: { sourceName: { eq: \"talks\" } } }) {\n      edges {\n        node {\n          id\n          html\n          frontmatter {\n            title\n            date\n            time\n            speaker\n            location\n            virtual\n            poster {\n              childImageSharp {\n                id\n                gatsbyImageData(layout: FULL_WIDTH)\n              }\n            }\n            poster_alt\n            tags\n          }\n          fields {\n            slug\n            sourceName\n          }\n        }\n      }\n    }\n    posts: allMarkdownRemark(\n      filter: { fields: { sourceName: { eq: \"posts\" } }, frontmatter: { show_on_frontpage: { eq: true } } }\n    ) {\n      edges {\n        node {\n          id\n          html\n          frontmatter {\n            title\n            date\n            show_on_frontpage\n          }\n          fields {\n            slug\n            sourceName\n          }\n        }\n      }\n    }\n    speakers: allMarkdownRemark(filter: { fields: { sourceName: { eq: \"speakers\" } } }) {\n      edges {\n        node {\n          id\n          html\n          frontmatter {\n            name\n            pic {\n              childImageSharp {\n                gatsbyImageData(layout: FULL_WIDTH)\n              }\n            }\n            twitter_name\n          }\n          fields {\n            slug\n            speakerId\n          }\n        }\n      }\n    }\n    locations: allMarkdownRemark(filter: { fields: { sourceName: { eq: \"locations\" } } }) {\n      edges {\n        node {\n          fields {\n            slug\n            locationId\n          }\n          frontmatter {\n            name\n            number\n            info\n            zip\n            city\n            street\n          }\n        }\n      }\n    }\n  }\n`\n\nexport { Head } from \"../components/head\"\n","import * as R from \"ramda\"\n\n/**\n * For each talk we cannot directly query the speaker info (especially the name) but only the speakerSlugs (not the full slug but the important\n * speaker-identifier with which we can create the slug)\n * we have to query all speakers in a separate query. Then we need to extract from this allSpeakers-list\n * only those speaker info objects that belong to a given talk. This is what this method is doing.\n *\n * @param allSpeakers an array of all speaker objects\n * @param talk a talk object\n */\nexport const findSpeakersForTalk = ({ allSpeakers, talk }) => {\n  return R.innerJoin(\n    (speaker, slug) => speaker.fields.slug === `/speakers/${slug}/`,\n    allSpeakers,\n    talk.frontmatter.speaker\n  )\n}\n","import moment from \"moment/moment\"\nimport * as R from \"ramda\"\n\n// TODO: fix typing\n\n/**\n * This function is used to determine the next upcoming event based on a list of events and the current date.\n * This is used to mark the next event in the list of all events and to determine which talk to show on the front page.\n *\n * If there is no event in the list the is in the future of today, then the last event is used.\n *\n *\n * @param allEvents a list of events\n * @param extractDate an optional function to extract the date from the event objects.\n * If no function is provided then a property \"frontmatter.date\" is used based on the markdown standard\n * @param today a date object of today. Usualy created by \"new Date()\" or a string representing today.\n * Basically anything that can parsed by moment.js\n */\nexport const getUpcomingEvent = ({\n  allEvents,\n  extractDate,\n  today,\n}: {\n  allEvents: Array<any>\n  extractDate?: any\n  today?: Date | string\n}) => {\n  if (!allEvents) {\n    return undefined\n  }\n\n  const extractor = extractDate ? extractDate : (edge) => edge.frontmatter.date\n\n  const sortedEvents = R.sortBy(extractor)(allEvents)\n\n  if (sortedEvents.length === 1) {\n    return sortedEvents[0]\n  }\n\n  const todayMoment = moment(today).startOf(\"day\")\n\n  const datesAfter = R.filter((event) => {\n    const date = moment(extractor(event)).startOf(\"day\")\n\n    return todayMoment.isSameOrBefore(date)\n  })(sortedEvents)\n\n  if (datesAfter && datesAfter.length > 0) {\n    return datesAfter[0]\n  } else {\n    return R.reverse(sortedEvents)[0]\n  }\n}\n"],"names":["PostPage","_ref","post","React","Link","to","fields","slug","frontmatter","title","date","formatDate","dangerouslySetInnerHTML","__html","html","_ref2","data","talks","edges","map","edge","node","posts","length","sortedPosts","R","Layout","key","today","Date","upcomingEvent","getUpcomingEvent","allEvents","speakers","locations","allSpeakers","allLocations","location","locationId","speakersOfTalk","findSpeakersForTalk","talk","TalkContent","speakerList","linkToDetailsPage","speaker","extractDate","extractor","sortedEvents","todayMoment","moment","startOf","datesAfter","event","isSameOrBefore"],"sourceRoot":""}