{"version":3,"sources":["webpack:///./node_modules/reactstrap/es/Badge.js","webpack:///./src/pages/tags.js"],"names":["props","className","cssModule","color","innerRef","pill","Tag","tag","attributes","classes","href","createElement","ref","defaultProps","TagsPage","data","talks","edges","map","edge","node","allSpeakers","speakers","tags","R","s","talk","frontmatter","sort","talksWithSpeakers","speakersOfTalk","findSpeakersForTalk","talksGroupedByTag","filteredTalk","filter","includes","key","style","margin","icon","faTag","tagGroup","Fragment","id","speakersString","speaker","name","to","fields","slug","title","dateTime","date","formatDate"],"mappings":"mOAWI,EAAQ,SAAeA,GACzB,IAAIC,EAAYD,EAAMC,UAClBC,EAAYF,EAAME,UAClBC,EAAQH,EAAMG,MACdC,EAAWJ,EAAMI,SACjBC,EAAOL,EAAMK,KACbC,EAAMN,EAAMO,IACZC,EAAa,YAA8BR,EAAO,CAAC,YAAa,YAAa,QAAS,WAAY,OAAQ,QAE1GS,EAAU,YAAgB,IAAWR,EAAW,QAAS,SAAWE,IAAOE,GAAO,cAAuBH,GAM7G,OAJIM,EAAWE,MAAgB,SAARJ,IACrBA,EAAM,KAGY,IAAMK,cAAcL,EAAK,YAAS,GAAIE,EAAY,CACpEP,UAAWQ,EACXG,IAAKR,MAIT,EAAMS,aA3Ba,CACjBV,MAAO,YACPE,MAAM,EACNE,IAAK,QAyBQ,Q,6FCmDAO,UArEE,SAAC,GAAc,IAAZC,EAAW,EAAXA,KACZC,EAAQD,EAAKC,MAAMC,MAAMC,KAAI,SAAAC,GAAI,OAAIA,EAAKC,QAE1CC,EAAcN,EAAKO,SAASL,MAAMC,KAAI,SAAAC,GAAI,OAAIA,EAAKC,QAEnDG,EAAOC,KACX,SAAAC,GAAC,OAAIA,IACLD,IAEEA,KAAQ,SAAAE,GAAI,OAAIA,EAAKC,YAAYJ,OAAjCC,CAAuCR,KAEzCY,OAEIC,EAAoBb,EAAME,KAAI,SAAAQ,GAClC,IAAMI,EAAiBC,IAAoB,CAAEV,cAAaK,SAE1D,OAAO,OAAP,UAAYA,EAAZ,CAAkBI,sBAGdE,EAAoBT,EAAKL,KAAI,SAAAX,GACjC,IAAM0B,EAAeJ,EAClBK,QAAO,SAAAR,GAAI,OAAIA,EAAKC,YAAYJ,QAChCW,QAAO,SAAAR,GAAI,OAAIA,EAAKC,YAAYJ,KAAKY,SAAS5B,MAEjD,MAAO,CACLA,MACAS,MAAOiB,MAIX,OACE,kBAAC,IAAD,KACE,oCACA,2BACGV,EAAKL,KAAI,SAAAX,GAAG,OACX,kBAAC,EAAD,CAAO6B,IAAK7B,EAAK8B,MAAO,CAAEC,OAAQ,UAAY5B,KAAI,IAAMH,GACtD,kBAAC,IAAD,CAAiBgC,KAAMC,MADzB,IACoCjC,OAKvCyB,EAAkBd,KAAI,SAAAuB,GACrB,IAAQlC,EAAekC,EAAflC,IAAKS,EAAUyB,EAAVzB,MAEb,OACE,kBAAC,IAAM0B,SAAP,CAAgBN,IAAK7B,GACnB,wBAAIoC,GAAIpC,GAAMA,GACd,4BACGS,EAAME,KAAI,SAAAQ,GACT,IAAMkB,EAAiBpB,IAAO,KAAPA,CAAaE,EAAKI,eAAeZ,KAAI,SAAA2B,GAAO,OAAIA,EAAQlB,YAAYmB,SAE3F,OACE,wBAAIV,IAAKV,EAAKiB,IACZ,0BAAM1C,UAAU,QACd,kBAAC,OAAD,CAAM8C,GAAIrB,EAAKsB,OAAOC,MAAOvB,EAAKC,YAAYuB,QAE/C,MAJH,IAIU,0BAAMC,SAAUzB,EAAKC,YAAYyB,MAAOC,YAAW3B,EAAKC,YAAYyB,OAC5E,kCAAQR","file":"component---src-pages-tags-js-e9782d30c9fe80616cf8.js","sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nimport React from 'react';\nimport classNames from 'classnames';\nimport { mapToCssModules, tagPropType } from './utils';\nvar defaultProps = {\n  color: 'secondary',\n  pill: false,\n  tag: 'span'\n};\n\nvar Badge = function Badge(props) {\n  var className = props.className,\n      cssModule = props.cssModule,\n      color = props.color,\n      innerRef = props.innerRef,\n      pill = props.pill,\n      Tag = props.tag,\n      attributes = _objectWithoutPropertiesLoose(props, [\"className\", \"cssModule\", \"color\", \"innerRef\", \"pill\", \"tag\"]);\n\n  var classes = mapToCssModules(classNames(className, 'badge', 'badge-' + color, pill ? 'badge-pill' : false), cssModule);\n\n  if (attributes.href && Tag === 'span') {\n    Tag = 'a';\n  }\n\n  return /*#__PURE__*/React.createElement(Tag, _extends({}, attributes, {\n    className: classes,\n    ref: innerRef\n  }));\n};\n\nBadge.defaultProps = defaultProps;\nexport default Badge;","import React from \"react\"\n\nimport { graphql, Link } from \"gatsby\"\n\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\"\nimport { faTag } from \"@fortawesome/free-solid-svg-icons\"\n\nimport { Badge } from \"reactstrap\"\n\nimport * as R from \"ramda\"\n\nimport Layout from \"../components/layout\"\nimport findSpeakersForTalk from \"../utils/find-speakers-for-talk\"\nimport formatDate from \"../utils/format-date\"\n\nconst TagsPage = ({ data }) => {\n  const talks = data.talks.edges.map(edge => edge.node)\n\n  const allSpeakers = data.speakers.edges.map(edge => edge.node)\n\n  const tags = R.filter(\n    s => s,\n    R.uniq(\n      // R.chain is equal to flatMap\n      R.chain(talk => talk.frontmatter.tags)(talks)\n    )\n  ).sort()\n\n  const talksWithSpeakers = talks.map(talk => {\n    const speakersOfTalk = findSpeakersForTalk({ allSpeakers, talk })\n\n    return { ...talk, speakersOfTalk }\n  })\n\n  const talksGroupedByTag = tags.map(tag => {\n    const filteredTalk = talksWithSpeakers\n      .filter(talk => talk.frontmatter.tags)\n      .filter(talk => talk.frontmatter.tags.includes(tag))\n\n    return {\n      tag,\n      talks: filteredTalk,\n    }\n  })\n\n  return (\n    <Layout>\n      <h2>Tags</h2>\n      <p>\n        {tags.map(tag => (\n          <Badge key={tag} style={{ margin: \"0.1rem\" }} href={`#${tag}`}>\n            <FontAwesomeIcon icon={faTag} /> {tag}\n          </Badge>\n        ))}\n      </p>\n\n      {talksGroupedByTag.map(tagGroup => {\n        const { tag, talks } = tagGroup\n\n        return (\n          <React.Fragment key={tag}>\n            <h3 id={tag}>{tag}</h3>\n            <ul>\n              {talks.map(talk => {\n                const speakersString = R.join(\", \")(talk.speakersOfTalk.map(speaker => speaker.frontmatter.name))\n\n                return (\n                  <li key={talk.id}>\n                    <span className=\"lead\">\n                      <Link to={talk.fields.slug}>{talk.frontmatter.title}</Link>\n                    </span>\n                    {\" | \"} <time dateTime={talk.frontmatter.date}>{formatDate(talk.frontmatter.date)}</time>\n                    <p>von {speakersString}</p>\n                  </li>\n                )\n              })}\n            </ul>\n          </React.Fragment>\n        )\n      })}\n    </Layout>\n  )\n}\n\nexport default TagsPage\n\nexport const query = graphql`\n  query {\n    talks: allMarkdownRemark(filter: { fields: { sourceName: { eq: \"talks\" } } }) {\n      edges {\n        node {\n          id\n          frontmatter {\n            title\n            date\n            tags\n            speaker\n          }\n          fields {\n            slug\n          }\n        }\n      }\n    }\n\n    speakers: allMarkdownRemark(filter: { fields: { sourceName: { eq: \"speakers\" } } }) {\n      edges {\n        node {\n          id\n          fields {\n            slug\n          }\n          frontmatter {\n            name\n          }\n        }\n      }\n    }\n  }\n`\n"],"sourceRoot":""}